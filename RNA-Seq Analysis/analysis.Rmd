---
title: RNA-Seq analysis
output:
    html_document:
        theme: yeti
        highlight: pygments
        code_folding: hide
        toc: true
        toc_depth: 2
        number_sections: true
        fig_width: 7
        fig_height: 6
        df_print: paged
---

```{r, message=F, warning=F}
library(DESeq2)
library(recount)
library(tidyverse)
```

# Load data

We use the data in the study with an SRA ID of `SRP007483`. We download the data
if it does not already exist.

```{r}
study_sra <- "SRP007483"
if (!file.exists(file.path(study_sra, "rse_gene.Rdata"))) {
    library(recount)
    download_study(study_sra, type = "rse-gene")
}
load(file.path(study_sra, "rse_gene.Rdata"))
```

# Examine data

```{r}
rse_gene
```

The class of the `rse_gene` object is `RangedSummarizedExperiment`. This is my
first peek into object oriented programming within R.

I see the dimensions of our data set. We have 12 columns, one for each sample. A
sample begins with a three letter prefix of `SRR`. What does this stand for?

It stands for [_Run_][1]. It is the data we got after running an experiment on a
sample.

## ENSG

We have 58,037 rows. They each start with a four letter prefix of `ENSG`. What
does this mean?

The row names are [Ensembl stable IDs][2]. The first three letters are `ENS`,
which tells us that these IDs are for humans. If the ID started with `ENSMUS`,
then it would mean that they're IDs for mouses. The fourth letter, `G`,
indicates that we're talking about _genes_, not transcripts or exons or another
entity.

There are also decimals within the row names. For example, one of the names is
__`r rownames(head(assays(rse_gene)$counts, 1))`__. What do the numbers after
the decimal point signify?

The `.14` indicates that this is the 14th version of the gene, which happens to
be [TSPAN6][3].

Why do genes have versions?

Sometimes, we reannotate the genome for a species. If we do, and the set of
transcripts (RNAs transcripted from the gene) linked to a gene changes, then we
increment the version.

## Biological conditions

```{r, rows.print=12}
bio_conditions <- colData(rse_gene)[c("run", "characteristics")] %>%
    as_tibble() %>%
    unnest(c(characteristics)) %>%
    separate(
        characteristics,
        c("characteristics_key", "characteristics_value"),
        sep = ": ") %>%
    pivot_wider(
        names_from = characteristics_key,
        values_from = characteristics_value)
bio_conditions
```

The first six samples are from brains of subjects with Autism. The other six
samples are from brains of subjects without Autism. Note that the control group
samples contain only regions `BA09` and `BA41` while the Autism group contains
those two regions and `BA22`. It is unclear whether this will have a significant
impact on analysis, but I wanted to point it out.

Let's put this biological condition data on our dataset.

```{r}
colData(rse_gene)$tissue <- factor(bio_conditions$tissue)
colData(rse_gene)$status <- factor(bio_conditions$"sample status")
```

## Preview of counts data

The following is a subset of the `counts` matrix given to us.

```{r}
bp_counts_tbl <- assay(rse_gene) %>%
    as.data.frame() %>%
    rownames_to_column("gene") %>%
    as_tibble()
head(bp_counts_tbl)
```

There are many more rows, but I only show a few here so that we can get an idea
of what the counts data look like. Each number in the table represents... TODO:
what does the base-pair count represent?

## Differential expression analysis

DESeq2 takes in a read count matrix. We convert the given base pair count matrix
to a read count matrix via `scale_counts`. Let's take a look at what this data
looks like.

```{r}
rse_gene <- scale_counts(rse_gene)
head(assay(rse_gene))
```

Looks good to me. Let's proceed with differential expression. First, we prep the
data set that we'll put into analyzer.

```{r}
de_data <- DESeqDataSet(rse_gene, ~ tissue + status)
de_data
```

Then, we run the analysis. Within the [`DESeq2` reference manual][4], there are
bunches of options we can use, but we'll use the default settings here.

```{r}
de_output <- DESeq(de_data)
```

```{r}
de_output
```


```{r}
res <- results(de_output)
```

The analysis opeation took a while on my computer. For that reason, we'll save
the results of that data onto our drive.

```{r}
write.csv(as.data.frame(res), file = "condition_control_autism.csv")
```

```{r}
normalized_de_output <- rlog(de_output)
```


Save results of operations that took a while to run.
```{r}
save(de_output, normalized_de_output, file = "deseq2_output.Rdata")
```

## Appendix

### Why recount2 publishes base pair counts

#### Confirm that the counts are base pair counts, not read counts

`recount2` gives us a `counts` matrix, but what are they counting? Base pairs?
Reads? Here is the sum of read counts reported by the SRA.
```{r}
reported_read_counts <- colData(rse_gene)["mapped_read_count"]
reported_read_counts_sum <- sum(reported_read_counts[[1]])
reported_read_counts_sum
```

Here is the sum of counts in the `counts` matrix.
```{r}
counts_matrix_sum <- sum(assay(rse_gene))
counts_matrix_sum
```

It's much higher. There are around 66 times more counts. That's pretty close to
the average read length of around 75. It would not make sense if the `counts`
matrix contains read counts. Let's sum up the counts in the `counts` matrix
after we apply the `scale_counts` function the authors of `recount` recommend we
use.

```{r}
total_read_counts <- sum(assay(scale_counts(rse_gene)))
total_read_counts
```

This number is much closer. So, we will continue, assuming that the `counts`
matrix contains base pair counts.

TODO: why is the count still higher?

## Questions

- Why do we have matching base pair counts, instead of matching read counts?
- How did we match up reads to genes in the first place?
    - Since reads won't match up completely to genes to due mutations, do we count
      the number of matching base pairs of the read to the gene?
    - What if we matched wrong?

[1]: https://linsalrob.github.io/ComputationalGenomicsManual/Databases/SRA.html
[2]: http://useast.ensembl.org/info/genome/stable_ids/index.html
[3]: http://useast.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000000003;r=X:100627108-100639991
[4]: https://bioconductor.org/packages/release/bioc/manuals/DESeq2/man/DESeq2.pdf

## Helpful learning links accompanied with questions

[Read length, single vs paired end, depth of coverage](https://systemsbiology.columbia.edu/genome-sequencing-defining-your-experiment)
 
- Are _fragment_ and _read_ interchangeable?
- Why do we do paired-end reading when we can just do single-end reading and
  take the reverse complement of each read? Is it because paired-end reading
  gives us redundancy, which is important for giving higher quality (i.e. lower
  error)?

[Beginner's guide to DESeq2](https://bioc.ism.ac.jp/packages/2.14/bioc/vignettes/DESeq2/inst/doc/beginner.pdf)

[RNA-Seq workflow](https://bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#introduction)

[DESeq2 paper](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8)
